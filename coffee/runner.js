// Generated by CoffeeScript 1.10.0
(function() {
  'use strict';
  var World, _, experiment0, experiment1, experiment2, experiment3, fs, generateConfig, generateData, generateTrainingSet, getParams, measureAverageSpeed, measureAverageWaitingTime, settings;

  require('./helpers');

  World = require('./model/world');

  _ = require('underscore');

  settings = require('./settings');

  fs = require('fs');

  measureAverageSpeed = function(setupCallback) {
    var i, k, map, results, world;
    world = new World();
    map = fs.readFileSync('./experiments/map.json', {
      encoding: 'utf8'
    });
    world.load(map);
    if (typeof setupCallback === "function") {
      setupCallback(world);
    }
    results = [];
    for (i = k = 0; k <= 10000; i = ++k) {
      world.onTick(0.2);
      results.push(world.instantSpeed);
    }
    return (results.reduce(function(a, b) {
      return a + b;
    })) / results.length;
  };

  measureAverageWaitingTime = function() {
    var avg, cnt, i, id, k, map, ref, t, world;
    world = new World();
    map = fs.readFileSync('../experiments/map.copy.json', {
      encoding: 'utf8'
    });
    world.load(map);
    for (i = k = 0; k <= 5000; i = ++k) {
      world.onTick(0.1);
    }
    avg = 0.0;
    cnt = 0;
    ref = world.intersectionAvgWaitingTime;
    for (id in ref) {
      t = ref[id];
      if (t > 0) {
        avg = avg + t;
        cnt = cnt + 1;
      }
    }
    avg = avg / cnt;
    return avg;
  };

  generateData = function() {
    var i, k, len, ref, t;
    t = [];
    ref = _.range(1000000);
    for (k = 0, len = ref.length; k < len; k++) {
      i = ref[k];
      t.push((_.sample(_.range(1, 31))) / 10);
    }
    return t;
  };

  generateConfig = function(world, t) {
    var intersect, k, len, ref, results1;
    ref = world.workingIntersections;
    results1 = [];
    for (k = 0, len = ref.length; k < len; k++) {
      intersect = ref[k];
      results1.push(intersect.controlSignals.delayMultiplier = _.sample(t, 4));
    }
    return results1;
  };

  generateTrainingSet = function() {
    var avg, cnt, i, id, intersect, j, k, l, len, len1, m, map, out, ref, ref1, ref2, results, results1, t, time, world;
    out = fs.createWriteStream('./experiments/0.data');
    t = generateData();
    map = fs.readFileSync('./experiments/map.json', {
      encoding: 'utf8'
    });
    ref = _.range(160);
    results1 = [];
    for (k = 0, len = ref.length; k < len; k++) {
      i = ref[k];
      console.log(i);
      world = new World();
      world.load(map);
      generateConfig(world, t);
      ref1 = world.workingIntersections;
      for (l = 0, len1 = ref1.length; l < len1; l++) {
        intersect = ref1[l];
        out.write(intersect.controlSignals.delayMultiplier + ', ');
        console.log(intersect.controlSignals.delayMultiplier);
      }
      results = [];
      for (j = m = 0; m <= 10000; j = ++m) {
        world.onTick(0.1);
      }
      avg = 0.0;
      cnt = 0;
      ref2 = world.intersectionAvgWaitingTime;
      for (id in ref2) {
        time = ref2[id];
        if (time > 0) {
          avg = avg + time;
          cnt = cnt + 1;
        }
      }
      avg = avg / cnt;
      out.write(avg + '\n');
      console.log(avg);
      results1.push(results.push(avg));
    }
    return results1;
  };

  getParams = function(world) {
    var i, id, params;
    params = (function() {
      var ref, results1;
      ref = world.intersections.all();
      results1 = [];
      for (id in ref) {
        i = ref[id];
        results1.push(i.controlSignals.flipMultiplier);
      }
      return results1;
    })();
    return params;
  };

  settings.lightsFlipInterval = 160;

  experiment0 = function() {
    var out, result;
    out = fs.createWriteStream('../experiments/0.data');
    result = measureAverageWaitingTime();
    console.log(result);
    return out.write(result + ' ');
  };

  experiment1 = function() {
    var k, len, multiplier, out, ref, results1;
    out = fs.createWriteStream('./experiments/1.data');
    out.write('multiplier avgSpeed\n');
    ref = [0.0001, 0.01, 0.02, 0.05, 0.1, 0.25, 0.5, 0.75, 1, 2, 3, 4, 5];
    results1 = [];
    for (k = 0, len = ref.length; k < len; k++) {
      multiplier = ref[k];
      results1.push((function(multiplier) {
        var result;
        result = measureAverageSpeed(function(world) {
          var i, id, ref1;
          ref1 = world.intersections.all();
          for (id in ref1) {
            i = ref1[id];
            i.controlSignals.flipMultiplier = multiplier;
          }
          return getParams(world);
        });
        return out.write(multiplier + ' ' + result + '\n');
      })(multiplier));
    }
    return results1;
  };

  experiment2 = function() {
    var it, k, out, result, results1;
    out = fs.createWriteStream('./experiments/2.data');
    out.write('it avgSpeed\n');
    results1 = [];
    for (it = k = 0; k <= 9; it = ++k) {
      result = measureAverageSpeed(function(world) {
        var i, id, ref;
        ref = world.intersections.all();
        for (id in ref) {
          i = ref[id];
          i.controlSignals.flipMultiplier = Math.random();
        }
        return getParams(world);
      });
      results1.push(out.write(it + ' ' + result + '\n'));
    }
    return results1;
  };

  experiment3 = function() {
    var it, k, out, result, results1;
    out = fs.createWriteStream('./experiments/3.data');
    out.write('it avgSpeed\n');
    results1 = [];
    for (it = k = 0; k <= 10; it = ++k) {
      result = measureAverageSpeed(function(world) {
        var i, id, ref;
        ref = world.intersections.all();
        for (id in ref) {
          i = ref[id];
          i.controlSignals.flipMultiplier = 1;
        }
        i.controlSignals.phaseOffset = 0;
        return getParams(world);
      });
      results1.push(out.write(it + ' ' + result + '\n'));
    }
    return results1;
  };

  experiment1();

  experiment0();

}).call(this);

//# sourceMappingURL=runner.js.map
