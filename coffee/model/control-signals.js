// Generated by CoffeeScript 1.10.0
(function() {
  'use strict';
  var ControlSignals, random, settings,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  random = Math.random;

  require('../helpers');

  settings = require('../settings');

  ControlSignals = (function() {
    function ControlSignals(intersection1) {
      this.intersection = intersection1;
      this.onTick = bind(this.onTick, this);
      this.flipMultiplier = random();
      this.phaseOffset = 100 * random();
      this.time = this.phaseOffset;
      this.stateNum = 0;
    }

    ControlSignals.copy = function(controlSignals, intersection) {
      var result;
      if (controlSignals == null) {
        return new ControlSignals(intersection);
      }
      result = Object.create(ControlSignals.prototype);
      result.flipMultiplier = controlSignals.flipMultiplier;
      result.time = result.phaseOffset = controlSignals.phaseOffset;
      result.stateNum = 0;
      result.intersection = intersection;
      return result;
    };

    ControlSignals.prototype.toJSON = function() {
      var obj;
      return obj = {
        flipMultiplier: this.flipMultiplier,
        phaseOffset: this.phaseOffset
      };
    };

    ControlSignals.prototype.states = [['L', '', 'L', ''], ['FR', '', 'FR', ''], ['', 'L', '', 'L'], ['', 'FR', '', 'FR']];

    ControlSignals.STATE = [
      {
        RED: 0,
        GREEN: 1
      }
    ];

    ControlSignals.property('flipInterval', {
      get: function() {
        return this.flipMultiplier * settings.lightsFlipInterval;
      }
    });

    ControlSignals.prototype._decode = function(str) {
      var state;
      state = [0, 0, 0];
      if (indexOf.call(str, 'L') >= 0) {
        state[0] = 1;
      }
      if (indexOf.call(str, 'F') >= 0) {
        state[1] = 1;
      }
      if (indexOf.call(str, 'R') >= 0) {
        state[2] = 1;
      }
      return state;
    };

    ControlSignals.property('state', {
      get: function() {
        var i, len, results, stringState, x;
        stringState = this.states[this.stateNum % this.states.length];
        if (this.intersection.roads.length <= 2) {
          stringState = ['LFR', 'LFR', 'LFR', 'LFR'];
        }
        results = [];
        for (i = 0, len = stringState.length; i < len; i++) {
          x = stringState[i];
          results.push(this._decode(x));
        }
        return results;
      }
    });

    ControlSignals.prototype.flip = function() {
      return this.stateNum += 1;
    };

    ControlSignals.prototype.onTick = function(delta) {
      this.time += delta;
      if (this.time > this.flipInterval) {
        this.flip();
        return this.time -= this.flipInterval;
      }
    };

    return ControlSignals;

  })();

  module.exports = ControlSignals;

}).call(this);

//# sourceMappingURL=control-signals.js.map
